#!/usr/bin/python

"""
*hadoop-mg*

CONTROL: shutdown or boot
all listed guests using start/stop
directive. Assure Hadoop services 
have been shutdown to avoid service
restart issues and accumulation of 
failed-process artifacts.

"""

import os
import sys
import time
import subprocess
import ConfigParser
from subprocess import Popen, PIPE

######## GLOBAL #########
CMD = 'virsh'           #
CLR = 0                 #
#########################

"""
Output to /dev/null

"""

def direct():

   return open(os.devnull, 'w')
   
"""
Configure host 
and guest names
on the system

"""

def config(name):

   MGT = os.environ['MANAGEMENT']
   
   conf = ConfigParser.RawConfigParser()
   
   conf.read(MGT + '/management.properties')
   
   prop = conf.get('KVM-HADOOP', name)
   
   return prop
   
"""
Send given command
to hosts vis ssh

"""

def connect(user, host, cmd):

   ssh = "ssh -t %s@%s %s" % (user, host, cmd)
   
   p = subprocess.check_call(ssh, shell=True, 
   
   stdout=direct(), stderr=subprocess.PIPE)
   
"""
Check whether guest
is running prior 
to execution

"""

def onoff(ipt):

   cmd = ['ping', ipt, '-c', '1']
   
   p = Popen(cmd, stdout=PIPE)
   
   output = p.communicate()[0]
   
   return p.returncode
   
"""
Run stop/stop
command over all
host machines

"""

def switch(rtn, mode, msg):

   global CLR
   
   host = config('hosts').split(',')
   
   virt = config('virtx').split(',')
   
   for h, v in zip(host, virt):
   
      if onoff(v) == rtn:
      
         cmd = "sudo %s %s %s" % (CMD, mode, h)
         
         idx = str(host.index(h) + 1)
         
         out = "shutdown " if rtn == 0 else "started "
         
         connect('master', 'moneygod%s' % (idx), cmd)
         
         print out + h
         
      else:
      
         print "%s\n%s" % (h, msg)
         
         CLR += 1
         
   return
   
"""
Following execution
of start/stop,
allow completion
of boot/shutdown cycle

"""

def clear(t):

   hosts = config('hosts').split(',')
   
   if CLR < len(hosts):
   
      for i in range(t, 0, -1):
      
         print 'clearing: %d \r' % i,
         
         sys.stdout.flush()
         
         time.sleep(1)
         
"""
Recall usage

"""

def usage():

   base = __file__.split('/')
   
   name = base[len(base) - 1]
   
   print "usage: %s (start|stop)" % (name)
   
   return
   
   
############### .__main()__.################### 
                                              #
if len(sys.argv) > 1:                         #
                                              #
   if sys.argv[1] == 'start':                 #
                                              #
      switch(1, 'start', config('mesg1'))     #
                                              #
      clear(60)                               #
                                              #
   elif sys.argv[1] == 'stop':                #
                                              #
      switch(0, 'shutdown', config('mesg2'))  #
                                              #
      clear(60)                               #
                                              #
   else:                                      #
                                              #
      usage()                                 #
                                              #
else:                                         #
                                              #
   usage()                                    #
############################################### 
